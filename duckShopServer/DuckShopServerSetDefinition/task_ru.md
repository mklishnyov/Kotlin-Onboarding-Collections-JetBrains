## Определение

`Sets` — это коллекции _уникальных_ элементов. Они отражают математическую абстракцию `Set`: группу объектов без дубликатов. Это означает, что если у нас есть два набора одинакового размера с одинаковыми объектами внутри, эти два набора будут равны.

![Определение множества](../../utils/src/main/resources/images/duck/shop/theory/set_definition.png)

<div class="hint" title="Различные реализации Set">

В отличие от `List`, `Set` обычно не сохраняет порядок элементов. Однако, как и в случае с `List`, можно использовать различные реализации `Set`, чтобы изменить это свойство: например, можно использовать реализацию `LinkedHashSet`, которая по умолчанию сортирует элементы в множестве.

Каждая реализация определяет не только набор возможных операций с этой коллекцией, но и сложность _этой_ операции. `LinkedHashSet`, если речь идет об обращении с использованием `contains`, просто является хеш-набором. Поэтому вставка элементов в связанный хеш-набор дешевле.
</div>

В общем случае `Set` содержит _только_ элементы _одного_ типа. В некоторых случаях возможно хранение элементов разных типов, но между ними должна быть _связь_, подробности см. в [документации](https://kotlinlang.org/docs/generics.html).

![Неправильный тип в множестве](../../utils/src/main/resources/images/duck/shop/theory/set_wrong_type.png)

Если у вас есть множество с объектами, например, с вашим собственным типом, как `Duck`, возможно переопределить поведение сравнения элементов в `Set`. По умолчанию для сравнения элементов внутри множества используется функция [`equals`](https://kotlinlang.org/docs/equality.html). Возможно переопределение этой функции и сравнение элементов только по части возможных свойств.

<div class="hint" title="Нажмите, чтобы увидеть пример сравнения элементов в Set только по части возможных свойств">

Рассмотрим пример.

Допустим, у нас есть класс `DuckNormal` с несколькими атрибутами:
```kotlin
data class DuckNormal(val backgroundColor: String, val accessories: List<String>)
```

Давайте переопределим методы `equals` и `hashCode`, чтобы сравнивать только `backgroundColor`:
```kotlin
data class DuckOverridden(val backgroundColor: String, val accessories: List<String>) {
    override fun equals(other: Any?) = backgroundColor == (other as? DuckOverridden)?.backgroundColor
  
    override fun hashCode() = backgroundColor.hashCode()
}
```

В этом случае `DuckNormal` будет сравниваться по `backgroundColor` и `accessories`, 
но `DuckOverridden` будет сравниваться _только_ по `backgroundColor`:

![Пример сравнения множеств](../../utils/src/main/resources/images/duck/shop/theory/set_equal_example.png)

Так как мы сравниваем только `backgroundColor`, множество во втором случае состоит только из одного элемента.

</div>

## Инициализация

Чтобы создать новое множество, можно использовать специальные _строители_:

```kotlin
val emptySet1 = emptySet<Int>() // Создает внутренний объект EmptySet
val emptySet2 = setOf<Int>() // Вызывает emptySet()
```

<div class="hint" title="Нажмите, чтобы узнать разницу между emptySet и стандартным набором">

В Kotlin реализация `emptySet` является объектом за кулисами. Основная причина существования такой функции заключается в экономии ресурсов (создание и удаление новых переменных). Поскольку `emptySet` возвращает один и тот же _синглтон_ каждый раз при вызове, его можно использовать без выделения ресурсов. Это позволяет вашей программе на Kotlin работать более эффективно.
</div>

```kotlin
val setWithNumbers = setOf(1, 2, 3) // Тип может быть выведен, будет создано множество с элементами 1, 2, 3
```