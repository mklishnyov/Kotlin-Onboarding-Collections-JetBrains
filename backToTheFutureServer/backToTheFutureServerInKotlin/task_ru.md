Подходы FIFO и LIFO, описанные выше, часто используются в программировании. Конечно, несложно реализовать такой подход самостоятельно: например, работая со списком. Однако многие языки программирования предлагают свои реализации, которые проводят различные виды оптимизаций. Kotlin не является исключением.

Давайте рассмотрим наш пример приложения. Как показано на первом шаге, в нашем тамагочи пользователь может переключать режим игры — очередь или стек. Это означает, что при выборе структуры данных нам важно, как быстро мы получаем элементы, не только с начала _или_ с конца, но и в _обоих_ сценариях.

<div class="hint" title="Нажмите, чтобы увидеть, как выглядит конечное приложение">

![Конечное приложение](../../utils/src/main/resources/images/tamagotchi/states/ready.gif)

</div>

Для таких случаев реализация [`ArrayDeque`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-deque/) является для нас наилучшим вариантом. Класс `ArrayDeque` предоставляет постоянное время выполнения для вставки и удаления элементов на обоих концах очереди, что делает его хорошим выбором для нашего сценария.

Чтобы создать новый пустой экземпляр `ArrayDeque`, вы можете вызвать его конструктор:
```kotlin
fun main() {
    val arrayDequeExample = ArrayDeque<Int>() // Создаем пустой ArrayDeque
}
```

**Примечание**, если вы добавите следующий импорт в верхней части файла
```kotlin
import java.util.ArrayDeque
```
и оставите то же определение `ArrayDeque`, вы будете использовать реализацию Java [`ArrayDeque`](https://docs.oracle.com/javase%2F7%2Fdocs%2Fapi%2F%2F/java/util/ArrayDeque.html), у которой разные названия методов, но основное значение остается тем же. _В Kotlin лучше использовать реализацию Kotlin._

Эта коллекция по умолчанию _изменяема_. Это означает, что, несмотря на использование ключевого слова `val`, мы можем обновлять саму коллекцию. В данном случае мы просто не можем _переприсвоить_ переменную.