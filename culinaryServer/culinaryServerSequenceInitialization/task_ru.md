Давайте вернемся к последовательностям. Как мы упоминали ранее, последовательности не _хранят_ элементы.  
Это влияет на несколько правил работы с последовательностями:

1) Обычно последовательность инициализируется по определённому _правилу_, задающему, как будет генерироваться следующий элемент. Например, если мы уже сварили помидоры и хотим добавить специи, правилом будет "достать следующую баночку специй с полки".

   **Обратите внимание, что это не всегда верно**, вы можете преобразовать список в последовательность, чтобы выполнить все действия вместе. Но это не будет хорошей идеей для быстрого выполнения операций с небольшими коллекциями, так как на преобразование в последовательность и обратно также потребуются ресурсы.

2) Если вы работаете с последовательностями, вам всегда нужно вызывать одну из _терминальных_ функций, чтобы действительно выполнить все действия.

   Обратите внимание, что последовательности могут быть бесконечными, поэтому будьте осторожны, вызывая _терминальную_ функцию без ограничения размера.

Рассмотрим примеры для обоих случаев. Представьте, что нам нужно сгенерировать последовательность специй для нашего томатного супа.  
Мы можем использовать функцию [`generateSequence`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/generate-sequence.html) с условием внутри:

```kotlin
val spices = generateSequence{ shelfWithSpices.getNextValidOne(...) }
```

В этом случае у нас фактически не будет этих `spices`, метод `shelfWithSpices.getNextValidOne(...)` будет вызываться каждый раз, когда это будет необходимо, то есть, когда нам действительно понадобится следующая баночка специй.  
Например, если для каждой баночки специй нужно добавить её в суп, и мы хотим добавить только 3 разные специи, это будет сделано следующим образом:

![Текущее состояние](../../utils/src/main/resources/images/master/chef/explanations/soup_cooking_spices.png)

Рассмотрим второй пример. _Терминальная_ функция необходима, чтобы показать компилятору Kotlin, что вы действительно готовы выполнить действия, например, `take(5)` или `toList()` для конечных последовательностей.  
В примере выше, если мы не используем `take(5)` и теоретически имеем бесконечную полку специй, мы не сможем обработать их все, так как ресурсы на нашем ноутбуке (или в кастрюле из примера) ограничены.

![Текущее состояние](../../utils/src/main/resources/images/master/chef/explanations/soup_cooking_spices_no_space.png)